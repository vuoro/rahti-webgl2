<!DOCTYPE html>
<html>
  <head>
    <script defer src="https://unpkg.com/es-module-shims@0.10.1/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "@vuoro/rahti": "https://cdn.skypack.dev/@vuoro/rahti",
          "gl-mat4-esm": "https://cdn.skypack.dev/gl-mat4-esm"
        }
      }
    </script>
  </head>

  <body>
    <canvas id="canvas"></canvas>

    <script type="module">
      import { root, state } from "@vuoro/rahti";
      import {
        context,
        uniformBlock,
        attribute,
        elements,
        instances,
        command,
        texture,
        createCamera,
      } from "./main.js";

      // is API for resources ok?
      // and for commands?
      // write each piece of the API

      const graphics = async function () {
        const thisContext = await this(context)(document.getElementById("canvas"));

        const shape = await this(attribute)(thisContext, [
          Float32Array.of(0, 0),
          Float32Array.of(1, 0),
          Float32Array.of(1, 1),
          Float32Array.of(0, 1),
        ]);
        const shared = await this(uniformBlock)(thisContext, { time: 0, lightColor: [0, 0, 0] });
        const smallTexture = await this(texture)(thisContext, {
          pixels: new Uint8Array(64 * 64 * 4).fill(128),
        });

        const [cameraController, camera] = await this(createCamera)(thisContext);

        const triangleElements = await this(elements)(thisContext, Int16Array.of(0, 1, 2));
        const quadElements = await this(elements)(thisContext, Int16Array.of(0, 1, 2, 2, 3, 0));

        const quadInstance = await this(instances)(thisContext, {
          color: [1, 1, 1],
          offset: [0, 0],
        });

        const drawTriangle = await this(command)(thisContext, {
          attributes: { shape },
          textures: { smallTexture },
          // elements: triangleElements,
          vertex: `
            out vec2 textureCoordinates;
            void main () {
              textureCoordinates = shape;
              gl_Position = vec4(shape, 0.0, 1.0);
            }
          `,
          fragment: `
            in vec2 textureCoordinates;
            out vec4 fragment;

            void main () {
              fragment = vec4(texture(smallTexture, textureCoordinates).rgb, 1.0);
            }
          `,
        });

        const drawQuad = await this(command)(thisContext, {
          attributes: { shape },
          uniformBlocks: { camera },
          elements: quadElements,
          instances: quadInstance,
          vertex: `
            out vec3 colorOut;

            void main () {
              colorOut = color;
              gl_Position = projectionView * vec4(shape + offset, -offset.x, 1.0);
            }
          `,
          fragment: `
            in vec3 colorOut;
            out vec4 fragment;

            void main () {
              fragment = vec4(colorOut, 1.0);
            }
          `,
        });

        // Later
        // const framebufferTest = framebuffer({ color: [smallTexture] });

        return {
          frame: thisContext.frame,
          commands: { drawTriangle, drawQuad, clear: thisContext.clear },
          quadInstance,
          shared,
          cameraController,
        };
      };

      const app = async function () {
        const { frame, commands, resources, quadInstance, shared, cameraController } = await this(
          graphics
        )();
        const { clear, drawTriangle, drawQuad } = commands;

        frame(() => {
          clear();
          drawTriangle();
          drawTriangle("LINES");
          drawQuad();
        });

        const [, { increment }] = await this(state)(0, getActions);
        setTimeout(increment, Math.random() * 20);

        const max = 5000 * Math.random();
        for (let index = 1; index < max; index++) {
          if (Math.random() > 0.5) this(quad, index)(index, quadInstance);
        }

        document.addEventListener("pointermove", ({ x, y }) => {
          cameraController.target[0] = -x * 0.001;
          cameraController.target[1] = y * 0.001;
        });
      };

      const getActions = (get, set) => ({
        increment: () => {
          set(get() + 1);
        },
      });

      const quad = function (index, quadInstance) {
        // const [, { increment }] = await this(state)(0, getActions);
        // setTimeout(increment, Math.random() * 1000);

        const attributes = {
          offset: Float32Array.of(-index * 0.1, -index * 0.1),
        };

        if (Math.random() > 0.5) attributes.color = [Math.random(), Math.random(), Math.random()];
        this(quadInstance)(attributes);
      };

      root(app)();
    </script>
  </body>
</html>
